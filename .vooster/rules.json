{
  "rules": [
    {
      "type": "prd",
      "content": "# Indie Game Galaxy – Product Requirements Document (PRD)\n\n## 1. 제품 개요\n‘Indie Game Galaxy’는 픽셀 아트 우주 맵에서 행성을 분양받아 게임을 전시하는 **웹 기반 인디게임 홍보·발견 플랫폼**입니다. 개발자는 저비용으로 개성 있는 행성을 꾸며 게임을 노출하고, 게이머는 로그인 없이 드래그·줌으로 우주를 탐험하며 새로운 인디게임을 발견합니다.\n\n## 2. 목표 및 성공 지표\n• 목표 1 – 개발자: 마케팅 비용 부담 없이 게임을 시각적으로 홍보할 수 있다.\n• 목표 2 – 게이머: 재미있는 탐험 경험을 통해 신작 인디게임을 쉽게 발견한다.\n\n### 핵심 KPI (MVP 기준)\n1. 행성 분양 신청 개발자 수 ≥ 50 (런칭 3개월)\n2. 월간 활성 게이머(MAU) ≥ 2,000\n3. 게이머 → 외부 다운로드/홈페이지 클릭률 ≥ 15%\n4. 개발자 행성 승인 시간(신청→승인) ≤ 48h\n\n## 3. 주요 사용자(Persona)\n1. **Indie Dev Dan** – 1~5인 규모 스튜디오의 리드 개발자. 예산이 부족하고, 게임 콘셉트를 시각적으로 돋보이게 노출하고 싶다.\n2. **Explorer Emma** – 신작 인디게임을 찾아다니는 20대 PC 게이머. 색다른 발견 경험을 선호하며 SNS 공유를 즐긴다.\n\n## 4. 핵심 문제점\n1. 과포화된 스팀·SNS 환경에서 인디게임이埋몰돼 홍보 난이도가 높다.\n2. 게이머들은 수많은 목록 UI에 지쳐 ‘발견의 재미’를 느끼기 어렵다.\n\n## 5. 핵심 가치 제안\n• 개발자에게: 저비용(무료 시작)으로 차별화된 브랜드 경험 제공.\n• 게이머에게: 게임 탐험 자체가 재미있는 인터랙티브 지도 제공.\n\n## 6. 기능 요구 사항\n\n| # | 기능 | 유저 | 우선순위 | 설명 |\n|---|------|------|---------|------|\n| F1 | 우주 맵 드래그·줌 인터랙션 | 게이머 | P0 | WebGL/Canvas 기반 무한 패닝, 마우스 휠 줌, 최소 FPS 45 유지 |\n| F2 | 행성 Hover 미리보기 | 게이머 | P0 | 행성 위에 마우스 올리면 미니 카드(게임명, 썸네일, 장르, 한줄 소개) 표시 |\n| F3 | 행성 클릭 상세 패널 | 게이머 | P0 | 좌측 회전 행성, 우측 반투명 정보 패널(설명, 스크린샷·GIF, 다운로드/홈페이지 버튼) |\n| F4 | 행성 분양 신청 폼 | 개발자 | P0 | 필드: 게임명, 설명, 장르, 썸네일, 스크린샷/GIF 업로드, 행성 유형 선택, 제출 버튼 |\n| F5 | 관리자 승인 대시보드 | 운영자 | P0 | 신청 리스트, 승인/거절, 미리보기 기능 |\n| F6 | 반응형 지원(데스크탑 중심) | 모든 | P1 | 1280px 이상 최적화, 1024px 이상 기본 지원, 모바일은 기본 뷰만 동작 |\n| F7 | 기본 분석 지표(클릭 수) | 개발자 | P2 | 외부 링크 클릭 수, 행성 방문 수 제공(대시보드) |\n\nMVP 범위 = F1~F5 + 최소 대응 반응형(F6). F7은 추후(β).\n\n## 7. 사용자 스토리 (MVP)\n• \"Indie Dev Dan으로서, 게임 정보를 입력해 ‘행성 분양’ 버튼을 누를 수 있어야 한다, 그래야 무료로 홍보를 시작할 수 있다.\"  \n• \"Explorer Emma로서, 우주 맵을 드래그·줌하며 행성에 마우스를 올려 게임을 미리보고, 클릭해 자세한 정보를 읽을 수 있어야 한다.\"  \n• \"운영자로서, 대시보드에서 신청을 확인하고 한 번의 클릭으로 승인하거나 거절할 수 있어야 한다.\"\n\n## 8. 기술·비기능 요구 사항\n• 플랫폼: Next.js 15 + TypeScript + WebGL/Canvas (Three.js or Pixi.js 후보)  \n• 성능: 데스크탑 Chrome 기준 45fps 이상 유지, 초당 렌더 행성 200개 지원  \n• SEO: 핵심 행성별 메타태그, OG 태그 생성(게이머 공유 대비)  \n• 접근성: 키보드 이동 불필요, ARIA 라벨 행성 정보 제공  \n• 보안: 업로드 파일 타입·사이즈 검증, Supabase 스토리지 이용  \n\n## 9. 수익화 및 운영 계획\n1단계: 완전 무료(MVP) → 2단계: 프리미엄 구독\n• 무료: 기본 행성(베이직 스킨), 외부 링크 1개, 기본 분석  \n• 프로: 고급 행성 스킨·꾸미기·애니메이션, 링크 3개, 고급 분석(CTR, 지역)  \n가격 예시: 월 $9 / 연 $90  \n\n## 10. 로드맵(6개월)\nMonth 1: 상세 기획 & 디자인 시안 완료  \nMonth 2–3: F1~F3 개발, 내부 테스트  \nMonth 4: F4, F5 개발, 클로즈드 베타(개발자 20명)  \nMonth 5: 퍼포먼스 튜닝, 공개 베타(플래닛 100개)  \nMonth 6: 초기 지표 분석 → 프리미엄 기능 설계 착수\n\n## 11. 성공 판정 기준 (Go/No Go)\n• 런칭 3개월 내 KPI 1·2 달성 + 게이머 클릭률 ≥ 15%  \n• 개발자 NPS ≥ 30  \n달성 시: 프리미엄·소셜 기능 개발로 단계적 확장. 미달성 시: 원인 분석 후 Pivot/중단 검토.",
      "writedAt": "2025-08-29T14:05:03.108Z"
    },
    {
      "type": "architecture",
      "content": "Of course. As a senior technical architect, my focus is on creating a specification that empowers the development team to build the right thing, quickly and effectively. The previous TRD was overly prescriptive and filled with project management details and implementation minutiae that are better decided by the team during sprints.\n\nThis revised version is a lean, actionable specification that respects the developers' expertise while ensuring the core architectural and business goals of the MVP are met.\n\n---\n\n# **Lean TRD: Indie Game Galaxy (MVP)**\n\n## 1. Executive Summary\n\nThis document outlines the core technical architecture for the Indie Game Galaxy MVP. Our goal is to rapidly validate the product's core loop: developers applying for planets and gamers exploring them.\n\nThe architecture prioritizes **speed of development, low operational overhead, and a performant user experience on desktop browsers.** We will build a serverless full-stack application using Next.js for the frontend and Supabase for the backend services. The interactive map will be rendered using PixiJS for high-performance 2D graphics.\n\n## 2. Core Architecture\n\n### **Guiding Principles**\n\n*   **Simplicity First:** Choose the most direct path to implementing MVP features. Avoid premature optimization and abstraction.\n*   **Serverless & Managed Services:** Rely on Supabase for database, auth, and storage to eliminate backend infrastructure management.\n*   **Desktop-Centric:** All performance and UI targets are based on modern desktop browsers (Chrome, Safari, Firefox). Mobile support is for viewing only.\n\n### **Tech Stack (MVP)**\n\n| Category         | Technology | Justification                                                              |\n| ---------------- | ---------- | -------------------------------------------------------------------------- |\n| **Framework**    | Next.js    | Provides SSR for SEO on planet pages and a robust React ecosystem.         |\n| **Language**     | TypeScript | Ensures type safety for API and data models, crucial for maintainability. |\n| **Backend**      | Supabase   | All-in-one BaaS (Database, Auth, Storage) for rapid MVP development.       |\n| **2D Rendering** | PixiJS     | High-performance 2D WebGL renderer optimized for sprites and interaction.  |\n| **Styling**      | TailwindCSS| A utility-first CSS framework for quickly building the required UI.        |\n\n### **System Diagram**\n\n```mermaid\ngraph TD\n    subgraph Browser\n        A[User: Gamer/Developer]\n    end\n\n    subgraph Vercel\n        B(Next.js Application)\n    end\n\n    subgraph Supabase\n        D[Postgres DB]\n        E[Storage: Images/GIFs]\n        F[Auth]\n    end\n\n    C(PixiJS Canvas)\n\n    A --> B\n    B -- Renders --> C\n    B -- Reads/Writes Data --> D\n    B -- Manages Files --> E\n    B -- Handles Auth --> F\n    C -- User Interaction --> B\n```\n\n### **Data Flow**\n\n1.  **Gamer (Explorer):** The Next.js app fetches all approved planet data from Supabase DB. PixiJS renders these planets on the canvas. User interactions (hover, click) are handled by PixiJS events, which trigger UI updates in React.\n2.  **Developer (Applicant):** The developer fills out a form in the Next.js app. On submission, game assets (images/GIFs) are uploaded to Supabase Storage, and the metadata is saved to the `planets` table with a `status` of `pending`.\n3.  **Admin:** The admin dashboard is a protected route in the Next.js app. It fetches `pending` planets from the database and provides simple \"approve\" or \"reject\" actions, which update the `status` field in the `planets` table.\n\n## 3. Key Technical Requirements (Non-Functional)\n\n*   **Performance:** The map must maintain **45 FPS** during navigation with up to **200** planets in the viewport.\n    *   **Mitigation:** Implement viewport culling (only rendering visible planets). Use texture atlases for planet sprites if needed.\n*   **SEO:** Individual planet pages (e.g., `/planet/[id]`) must be server-side rendered (SSR) with appropriate `<title>` and Open Graph meta tags for social sharing.\n*   **Security:**\n    *   **File Uploads:** All uploads to Supabase Storage must be validated server-side for file type (`jpeg`, `png`, `gif`) and size (< 5MB).\n    *   **Data Access:** Use Supabase Row-Level Security (RLS) policies.\n        *   Public users can only `read` approved planets.\n        *   Authenticated admins can `read` all planets and `update` their status.\n        *   Authenticated developers can `create` planets and `update` their own.\n\n## 4. Data Model (Supabase/PostgreSQL)\n\nThis is the essential data structure for the MVP.\n\n**Table: `planets`**\n\n| Column          | Type      | Constraints / Notes                                         |\n| --------------- | --------- | ----------------------------------------------------------- |\n| `id`            | `uuid`    | Primary Key, auto-generated                                 |\n| `created_at`    | `timestamptz` | Auto-generated                                            |\n| `game_name`     | `text`    | Not Null                                                    |\n| `description`   | `text`    |                                                             |\n| `genre`         | `text`    |                                                             |\n| `thumbnail_url` | `text`    | URL from Supabase Storage                                   |\n| `media_urls`    | `text[]`  | Array of URLs for screenshots/GIFs                          |\n| `planet_type`   | `text`    | e.g., 'terran', 'gas_giant'. Default 'terran'.              |\n| `website_url`   | `text`    | External link to game's homepage or store page              |\n| `status`        | `text`    | `pending`, `approved`, `rejected`. Default `pending`.       |\n| `developer_id`  | `uuid`    | Foreign Key to `auth.users` table.                          |\n| `position`      | `jsonb`   | `{ \"x\": number, \"y\": number }`. Assigned on approval.       |\n\n**Note:** The `developers` are managed by the built-in Supabase `auth.users` table. We will add a simple `admin` role for the approval dashboard.",
      "writedAt": "2025-08-29T14:05:03.108Z"
    },
    {
      "type": "guideline",
      "content": "\n    # Senior Developer Guidelines\n    \n    ## Must\n    \n    - always use client component for all components. (use `use client` directive)\n    - always use promise for page.tsx params props.\n    - use valid picsum.photos stock image for placeholder image\n    \n    ## Library\n    \n    use following libraries for specific functionalities:\n    \n    1. `date-fns`: For efficient date and time handling.\n    2. `ts-pattern`: For clean and type-safe branching logic.\n    3. `@tanstack/react-query`: For server state management.\n    4. `zustand`: For lightweight global state management.\n    5. `react-use`: For commonly needed React hooks.\n    6. `es-toolkit`: For robust utility functions.\n    7. `lucide-react`: For customizable icons.\n    8. `zod`: For schema validation and data integrity.\n    9. `shadcn-ui`: For pre-built accessible UI components.\n    10. `tailwindcss`: For utility-first CSS styling.\n    11. `supabase`: For a backend-as-a-service solution.\n    12. `react-hook-form`: For form validation and state management.\n    \n    ## Directory Structure\n    \n    - src\n    - src/app: Next.js App Routers\n    - src/components/ui: shadcn-ui components\n    - src/constants: Common constants\n    - src/hooks: Common hooks\n    - src/lib: utility functions\n    - src/remote: http client\n    - src/features/[featureName]/components/*: Components for specific feature\n    - src/features/[featureName]/constants/*\n    - src/features/[featureName]/hooks/*\n    - src/features/[featureName]/lib/*\n    - src/features/[featureName]/api.ts: api fetch functions\n    \n    ## Solution Process:\n    \n    1. Rephrase Input: Transform to clear, professional prompt.\n    2. Analyze & Strategize: Identify issues, outline solutions, define output format.\n    3. Develop Solution:\n       - \"As a senior-level developer, I need to [rephrased prompt]. To accomplish this, I need to:\"\n       - List steps numerically.\n       - \"To resolve these steps, I need the following solutions:\"\n       - List solutions with bullet points.\n    4. Validate Solution: Review, refine, test against edge cases.\n    5. Evaluate Progress:\n       - If incomplete: Pause, inform user, await input.\n       - If satisfactory: Proceed to final output.\n    6. Prepare Final Output:\n       - ASCII title\n       - Problem summary and approach\n       - Step-by-step solution with relevant code snippets\n       - Format code changes:\n        ```language:path/to/file\n         // ... existing code ...\n         function exampleFunction() {\n             // Modified or new code here\n         }\n         // ... existing code ...\n         ```\n       - Use appropriate formatting\n       - Describe modifications\n       - Conclude with potential improvements\n    \n    ## Key Mindsets:\n    \n    1. Simplicity\n    2. Readability\n    3. Maintainability\n    4. Testability\n    5. Reusability\n    6. Functional Paradigm\n    7. Pragmatism\n    \n    ## Code Guidelines:\n    \n    1. Early Returns\n    2. Conditional Classes over ternary\n    3. Descriptive Names\n    4. Constants > Functions\n    5. DRY\n    6. Functional & Immutable\n    7. Minimal Changes\n    8. Pure Functions\n    9. Composition over inheritance\n    \n    ## Functional Programming:\n    \n    - Avoid Mutation\n    - Use Map, Filter, Reduce\n    - Currying and Partial Application\n    - Immutability\n    \n    ## Code-Style Guidelines\n    \n    - Use TypeScript for type safety.\n    - Follow the coding standards defined in the ESLint configuration.\n    - Ensure all components are responsive and accessible.\n    - Use Tailwind CSS for styling, adhering to the defined color palette.\n    - When generating code, prioritize TypeScript and React best practices.\n    - Ensure that any new components are reusable and follow the existing design patterns.\n    - Minimize the use of AI generated comments, instead use clearly named variables and functions.\n    - Always validate user inputs and handle errors gracefully.\n    - Use the existing components and pages as a reference for the new components and pages.\n    \n    ## Performance:\n    \n    - Avoid Premature Optimization\n    - Profile Before Optimizing\n    - Optimize Judiciously\n    - Document Optimizations\n    \n    ## Comments & Documentation:\n    \n    - Comment function purpose\n    - Use JSDoc for JS\n    - Document \"why\" not \"what\"\n    \n    ## Function Ordering:\n    \n    - Higher-order functionality first\n    - Group related functions\n    \n    ## Handling Bugs:\n    \n    - Use TODO: and FIXME: comments\n    \n    ## Error Handling:\n    \n    - Use appropriate techniques\n    - Prefer returning errors over exceptions\n    \n    ## Testing:\n    \n    - Unit tests for core functionality\n    - Consider integration and end-to-end tests\n    \n    ## Next.js\n    \n    - you must use promise for page.tsx params props.\n    \n    ## Shadcn-ui\n    \n    - if you need to add new component, please show me the installation instructions. I'll paste it into terminal.\n    - example\n      ```\n      $ npx shadcn@latest add card\n      $ npx shadcn@latest add textarea\n      $ npx shadcn@latest add dialog\n      ```\n    \n    ## Supabase\n    \n    - if you need to add new table, please create migration. I'll paste it into supabase.\n    - do not run supabase locally\n    - store migration query for `.sql` file. in /supabase/migrations/\n    \n    ## Package Manager\n    \n    - use npm as package manager.\n    \n    ## Korean Text\n    \n    - 코드를 생성한 후에 utf-8 기준으로 깨지는 한글이 있는지 확인해주세요. 만약 있다면 수정해주세요.\n    \n    You are a senior full-stack developer, one of those rare 10x devs. Your focus: clean, maintainable, high-quality code.\n    Apply these principles judiciously, considering project and team needs.\n      ",
      "writedAt": "2025-08-29T14:05:03.108Z"
    },
    {
      "type": "design-guide",
      "content": "# Indie Game Galaxy Design Guide\n\n## 1. Overall Mood (전체적인 무드)\n\nIndie Game Galaxy는 **혁신적이고 미래지향적인 우주 탐험 경험**을 제공하는 서비스입니다. 깊은 우주의 어둠 속에서 네온 픽셀 아트가 빛나는 **사이버펑크와 레트로 퓨처리즘이 결합된 독특한 분위기**를 연출합니다. \n\n핵심 디자인 철학은 **\"Ultra-minimal Immersion\"** - 사용자가 복잡한 UI에 방해받지 않고 순수한 탐험의 즐거움에 몰입할 수 있도록 최소한의 인터페이스로 최대한의 경험을 제공합니다. 어두운 우주 배경 위에 생동감 넘치는 네온 컬러가 대비를 이루며, 픽셀 아트 행성들이 마치 살아있는 것처럼 빛나는 **신비롭고 탐험 욕구를 자극하는 분위기**를 조성합니다.\n\n## 2. Reference Service (참조 서비스)\n\n- **Name**: Hyper Light Drifter\n- **Description**: 네온 픽셀 아트와 사이버펑크 미학이 결합된 액션 RPG 게임\n- **Design Mood**: 어두운 배경 위에 생동감 넘치는 네온 컬러가 대비를 이루는 미래지향적 픽셀 아트 스타일\n- **Primary Color**: #ff2d9d (네온 마젠타)\n- **Secondary Color**: #05d9e8 (네온 시안)\n\n## 3. Color & Gradient (색상 & 그라데이션)\n\n- **Primary Color**: #ff2d9d (네온 마젠타) - 주요 CTA 버튼 및 강조 요소\n- **Secondary Color**: #05d9e8 (네온 시안) - 호버 상태 및 글로우 효과\n- **Background Primary**: #000000 (딥 스페이스 블랙) - 메인 배경\n- **Background Secondary**: #0a093d (미드나이트 네이비) - 서브 배경 및 카드\n- **Surface Color**: #4b1d79 (코스믹 퍼플) - 큰 면적의 카드 및 패널\n- **Text Primary**: #ffffff (화이트) - 주요 텍스트\n- **Text Secondary**: #b8b8b8 (라이트 그레이) - 보조 텍스트\n\n**Mood**: 쿨톤 계열의 고대비 네온 컬러로 미래적이고 신비로운 분위기\n\n**Color Usage**: \n- 최고 중요도: 네온 마젠타 (주요 액션 버튼, 선택 상태)\n- 높은 중요도: 네온 시안 (호버 상태, 보조 액션)\n- 중간 중요도: 코스믹 퍼플 (정보 패널, 카드 배경)\n- 기본 중요도: 미드나이트 네이비 (서브 배경)\n- 베이스: 딥 스페이스 블랙 (메인 배경)\n\n## 4. Typography & Font (타이포그래피 & 폰트)\n\n- **Heading 1**: Orbitron Bold, 32px, Weight 700 - 메인 타이틀 및 로고\n- **Heading 2**: Orbitron Medium, 24px, Weight 500 - 섹션 헤더\n- **Heading 3**: Orbitron Regular, 18px, Weight 400 - 서브 헤더\n- **Body Large**: Noto Sans KR Medium, 16px, Weight 500 - 주요 본문\n- **Body**: Noto Sans KR Regular, 14px, Weight 400 - 일반 본문\n- **Caption**: Noto Sans KR Light, 12px, Weight 300 - 보조 설명\n- **Pixel Label**: Press Start 2P Regular, 10px, Weight 400 - 픽셀 스타일 라벨\n\n**Letter Spacing**: \n- Orbitron: 0.5px (미래적 느낌 강화)\n- Noto Sans KR: 0px (자연스러운 가독성)\n- Press Start 2P: 1px (픽셀 아트 감성)\n\n## 5. Layout & Structure (레이아웃 & 구조)\n\n**Grid System**: \n- 데스크탑 (>1280px): 12컬럼 그리드, 24px 거터\n- 태블릿 (768-1279px): 8컬럼 그리드, 20px 거터\n- 모바일 (<768px): 4컬럼 그리드, 16px 거터\n\n**Layout Principles**:\n- **Full-Screen Immersion**: 우주 맵이 전체 화면을 차지하는 몰입형 레이아웃\n- **Minimal Navigation**: 상단에 얇은 네비게이션 바만 배치 (높이 64px)\n- **Floating Elements**: 정보 패널과 카드는 우주 배경 위에 떠있는 형태\n- **Z-Index Hierarchy**: 배경(0) → 행성(10) → 호버 카드(100) → 상세 패널(200) → 모달(300)\n\n**Spacing System**:\n- 기본 단위: 8px\n- 컴포넌트 간격: 16px, 24px, 32px\n- 섹션 간격: 48px, 64px\n- 페이지 여백: 80px (데스크탑), 40px (태블릿), 24px (모바일)\n\n## 6. Visual Style (비주얼 스타일)\n\n**아이콘 스타일**:\n- 16bit 픽셀 아트 스타일 아이콘 (16×16px, 24×24px)\n- 네온 글로우 효과 적용\n- 단순하고 기하학적인 형태\n- 2px 스트로크 두께 유지\n\n**이미지 처리**:\n- 행성 썸네일: 64×64px 픽셀 아트, 외곽 글로우 효과\n- 게임 스크린샷: 16:9 비율, 모서리 4px 라운드\n- GIF 애니메이션: 최대 2MB, 자동 재생\n\n**글로우 & 효과**:\n- 네온 글로우: `box-shadow: 0 0 20px rgba(255, 45, 157, 0.6)`\n- 호버 글로우: `box-shadow: 0 0 30px rgba(5, 217, 232, 0.8)`\n- 페이드 애니메이션: 300ms ease-in-out\n- 스케일 애니메이션: 200ms ease-out\n\n**일러스트레이션 가이드**:\n- 8-16bit 픽셀 아트 스타일 유지\n- 우주 테마: 별, 행성, 우주선, 외계 생물\n- 제한된 컬러 팔레트 사용 (최대 8색)\n- 애니메이션: 단순한 점멸, 회전 효과\n\n## 7. UX Guide (UX 가이드)\n\n**타겟 사용자 대응 전략**:\n- **초보자와 전문가 모두**: 직관적인 드래그 앤 드롭 인터랙션으로 학습 곡선 최소화\n- **인지 부하 최소화**: 복잡한 메뉴나 튜토리얼 없이 즉시 탐험 가능\n- **발견의 즐거움**: 예측 불가능한 행성 배치로 세렌디피티 경험 제공\n\n**핵심 UX 원칙**:\n\n1. **즉시 몰입 (Immediate Immersion)**\n   - 로딩 완료 즉시 인터랙션 가능\n   - 온보딩 없이 직관적 조작\n   - 3초 이내 첫 번째 행성 발견 유도\n\n2. **자연스러운 탐험 (Natural Exploration)**\n   - 마우스 드래그: 부드러운 관성 스크롤\n   - 휠 줌: 연속적이고 자연스러운 확대/축소\n   - 행성 호버: 즉각적인 미리보기 피드백\n\n3. **명확한 피드백 (Clear Feedback)**\n   - 호버 상태: 글로우 효과로 상호작용 가능성 표시\n   - 클릭 피드백: 200ms 내 시각적 반응\n   - 로딩 상태: 우주 테마 로딩 애니메이션\n\n4. **컨텍스트 유지 (Context Preservation)**\n   - 뒤로 가기 시 이전 위치 기억\n   - 브라우저 히스토리 지원\n   - 상세 패널 닫기 시 부드러운 애니메이션\n\n## 8. UI Component Guide (UI 컴포넌트 가이드)\n\n### 버튼 (Buttons)\n**Primary Button**:\n- 배경: 네온 마젠타 (#ff2d9d)\n- 텍스트: 화이트 (#ffffff)\n- 패딩: 12px 24px\n- 보더: 없음\n- 라운드: 8px\n- 호버: 네온 시안 글로우 효과\n- 폰트: Noto Sans KR Medium 14px\n\n**Secondary Button**:\n- 배경: 투명\n- 텍스트: 네온 시안 (#05d9e8)\n- 보더: 1px solid #05d9e8\n- 호버: 배경 네온 시안 10% opacity\n\n**Ghost Button**:\n- 배경: 투명\n- 텍스트: 화이트 (#ffffff)\n- 호버: 네온 마젠타 20% opacity 배경\n\n### 입력 필드 (Input Fields)\n- 배경: 미드나이트 네이비 (#0a093d)\n- 보더: 1px solid #4b1d79\n- 포커스: 네온 시안 보더 + 글로우\n- 패딁: 12px 16px\n- 라운드: 6px\n- 플레이스홀더: 라이트 그레이 (#b8b8b8)\n\n### 카드 (Cards)\n**호버 미리보기 카드**:\n- 배경: 코스믹 퍼플 (#4b1d79) 80% opacity\n- 백드롭 블러: 10px\n- 보더: 1px solid rgba(255, 255, 255, 0.1)\n- 라운드: 12px\n- 패딩: 16px\n- 그림자: 0 8px 32px rgba(0, 0, 0, 0.5)\n\n**상세 정보 패널**:\n- 배경: 미드나이트 네이비 (#0a093d) 95% opacity\n- 크기: 400px × 600px (데스크탑)\n- 애니메이션: 우측에서 슬라이드 인\n- 닫기 버튼: 우상단 × 버튼\n\n### 네비게이션 (Navigation)\n**상단 네비게이션 바**:\n- 높이: 64px\n- 배경: 딥 스페이스 블랙 (#000000) 90% opacity\n- 백드롭 블러: 20px\n- 로고: 좌측 정렬, Orbitron Bold\n- CTA 버튼: 우측 정렬, Primary Button 스타일\n\n### 토스트 알림 (Toast Notifications)\n- 배경: 코스믹 퍼플 (#4b1d79)\n- 위치: 우상단\n- 애니메이션: 위에서 슬라이드 다운\n- 지속시간: 4초\n- 아이콘: 16×16px 픽셀 아트\n\n### 로딩 상태 (Loading States)\n- 스피너: 회전하는 픽셀 아트 행성\n- 배경: 반투명 오버레이\n- 텍스트: \"우주를 탐험하는 중...\" (Noto Sans KR)\n- 애니메이션: 2초 주기 회전\n\n### 폼 컴포넌트 (Form Components)\n**파일 업로드**:\n- 드래그 앤 드롭 영역: 점선 보더\n- 호버: 네온 시안 보더\n- 업로드 완료: 네온 마젠타 체크 아이콘\n- 진행률: 네온 그라데이션 프로그레스 바\n\n**선택 옵션 (행성 유형)**:\n- 64×64px 픽셀 아트 미리보기\n- 선택 상태: 네온 마젠타 글로우\n- 그리드 레이아웃: 3×2 (데스크탑)",
      "writedAt": "2025-08-29T14:05:03.108Z"
    },
    {
      "type": "ia",
      "content": "# Indie Game Galaxy Information Architecture (IA)\n\n## 1. 사이트맵 (Site Map)\n\n```\nIndie Game Galaxy\n├── / (우주 맵 홈)\n├── /adopt-planet (행성 분양 신청)\n├── /submission-success (신청 완료)\n├── /planet/:id (행성 상세 - 모달/딥링크)\n├── /admin (관리자 대시보드)\n│   ├── /admin/login (관리자 로그인)\n│   ├── /admin/dashboard (승인 관리)\n│   ├── /admin/planets (행성 현황)\n│   └── /admin/analytics (기본 통계)\n├── /404 (페이지를 찾을 수 없음)\n└── /500 (서버 오류)\n```\n\n## 2. 사용자 흐름 (User Flow)\n\n### 핵심 작업 1: 게이머의 게임 발견 여정\n1. 사용자가 메인 URL 접속\n2. 우주 맵 자동 로딩 (3초 이내)\n3. 마우스 드래그로 우주 공간 탐험\n4. 관심 있는 행성에 마우스 호버\n5. 미리보기 카드 팝업 확인\n6. 행성 클릭 → 상세 모달 오픈\n7. 게임 정보 확인 후 외부 링크 클릭\n8. 새 탭에서 스팀/홈페이지 이동\n9. 브라우저 돌아와서 계속 탐험\n\n### 핵심 작업 2: 개발자의 행성 분양 신청\n1. 상단 네비게이션 \"Adopt Your Planet\" 버튼 클릭\n2. `/adopt-planet` 페이지로 이동\n3. 게임 정보 입력 폼 작성\n   - 게임명, 설명, 장르 선택\n   - 썸네일 이미지 업로드 (드래그 앤 드롭)\n   - 스크린샷/GIF 업로드\n   - 행성 유형 선택 (픽셀 아트 미리보기)\n   - 외부 링크 입력\n4. \"Submit for Review\" 버튼 클릭\n5. `/submission-success` 페이지로 리다이렉트\n6. 확인 메시지 및 예상 승인 시간 안내\n7. 이메일로 승인 알림 대기\n\n### 핵심 작업 3: 관리자의 승인 관리\n1. `/admin/login`에서 2FA 로그인\n2. `/admin/dashboard` 대시보드 접속\n3. \"Pending\" 탭에서 신규 신청 목록 확인\n4. 각 신청 항목 클릭하여 상세 정보 검토\n5. 필요 시 \"Preview Planet\" 버튼으로 미리보기\n6. \"Approve\" 또는 \"Reject\" 버튼 클릭\n7. 상태 변경 및 개발자에게 이메일 발송\n8. `/admin/analytics`에서 일간 승인 통계 확인\n\n## 3. 네비게이션 구조 (Navigation Structure)\n\n### 글로벌 네비게이션 바 (GNB)\n- **위치**: 상단 고정 (64px 높이)\n- **배경**: 반투명 딥 스페이스 블랙 + 백드롭 블러\n- **좌측**: 로고 \"Indie Game Galaxy\" (Orbitron Bold)\n- **우측**: \"Adopt Your Planet\" 버튼 (Primary Button 스타일)\n\n### 관리자 네비게이션 (Admin Only)\n- **사이드바 네비게이션** (관리자 페이지 전용)\n  - Dashboard (승인 관리)\n  - Planets (행성 현황)\n  - Analytics (기본 통계)\n  - Logout\n\n### 푸터 (Footer)\n- **최소한의 푸터** (우주 맵 하단)\n- 저작권 정보, 이용약관, 개인정보처리방침\n- 소셜 미디어 링크 (픽셀 아트 아이콘)\n\n## 4. 페이지 계층 구조 (Page Hierarchy)\n\n```\n/ (Depth 0 - 루트)\n├── adopt-planet (Depth 1)\n├── submission-success (Depth 1)\n├── planet/:id (Depth 1 - 동적 라우트)\n├── admin (Depth 1)\n│   ├── login (Depth 2)\n│   ├── dashboard (Depth 2)\n│   ├── planets (Depth 2)\n│   └── analytics (Depth 2)\n├── 404 (Depth 1)\n└── 500 (Depth 1)\n```\n\n## 5. 콘텐츠 구성 (Content Organization)\n\n| 페이지 | 주요 콘텐츠 요소 |\n|---|---|\n| **우주 맵 (/)** | WebGL/Canvas 우주 배경, 픽셀 아트 행성들, 호버 미리보기 카드, 상세 모달 오버레이, 글로벌 네비게이션 |\n| **행성 분양 (/adopt-planet)** | 신청 폼, 게임 정보 입력 필드, 파일 업로드 영역, 행성 유형 선택 그리드, 제출 버튼 |\n| **신청 완료 (/submission-success)** | 성공 메시지, 예상 승인 시간, 이메일 알림 안내, 홈으로 돌아가기 버튼 |\n| **행성 상세 (모달)** | 회전하는 3D 행성, 게임 정보 패널, 스크린샷/GIF 갤러리, 외부 링크 버튼, 닫기 버튼 |\n| **관리자 대시보드** | 신청 목록 테이블, 승인/거절 버튼, 미리보기 기능, 상태 필터, 검색 기능 |\n| **에러 페이지** | 픽셀 아트 에러 일러스트, 에러 메시지, 홈으로 돌아가기 버튼 |\n\n## 6. 인터랙션 패턴 (Interaction Patterns)\n\n### 우주 맵 인터랙션\n- **드래그 패닝**: 마우스 드래그로 무한 스크롤, 관성 효과 적용\n- **휠 줌**: 마우스 위치 기준 연속적 확대/축소\n- **행성 호버**: 즉시 미리보기 카드 표시, 글로우 효과\n- **행성 클릭**: 상세 모달 오픈, 배경 블러 처리\n\n### 폼 인터랙션\n- **파일 업로드**: 드래그 앤 드롭 + 클릭 업로드, 진행률 표시\n- **실시간 검증**: 필드별 즉시 피드백, 에러 상태 표시\n- **행성 유형 선택**: 클릭으로 선택, 선택 상태 글로우 효과\n\n### 피드백 패턴\n- **토스트 알림**: 우상단에서 슬라이드 다운, 4초 자동 사라짐\n- **로딩 상태**: 회전하는 픽셀 행성 스피너\n- **호버 피드백**: 200ms 내 글로우 효과 표시\n- **클릭 피드백**: 버튼 스케일 애니메이션\n\n### 모달 패턴\n- **상세 모달**: 중앙 오버레이, 배경 클릭으로 닫기\n- **확인 모달**: 중요한 액션 전 확인 요청\n- **ESC 키**: 모든 모달 닫기 지원\n\n## 7. URL 구조 (URL Structure)\n\n### 일반 페이지\n- **홈페이지**: `/`\n- **행성 분양**: `/adopt-planet`\n- **신청 완료**: `/submission-success`\n\n### 동적 라우트\n- **행성 상세**: `/planet/[planet-id]` (예: `/planet/cosmic-runner-2024`)\n- **관리자 페이지**: `/admin/[section]`\n\n### SEO 최적화 URL\n- **행성 ID**: 게임명 기반 slug (예: `cosmic-runner-2024`)\n- **소문자 + 하이픈**: 일관된 네이밍 컨벤션\n- **의미있는 경로**: 계층 구조 반영\n\n### 쿼리 매개변수\n- **우주 맵 위치**: `/?x=1200&y=800&zoom=1.5` (공유용)\n- **필터링**: `/admin/dashboard?status=pending&sort=date`\n- **페이지네이션**: `/admin/planets?page=2&limit=20`\n\n## 8. 컴포넌트 계층 구조 (Component Hierarchy)\n\n### 글로벌 컴포넌트\n- **Header**: 상단 네비게이션 바\n- **Footer**: 최소한의 하단 정보\n- **ToastSystem**: 전역 알림 관리\n- **LoadingSpinner**: 픽셀 아트 로딩 애니메이션\n- **ErrorBoundary**: 에러 처리 래퍼\n\n### 우주 맵 컴포넌트\n- **UniverseCanvas**: WebGL/Canvas 메인 컨테이너\n- **PlanetRenderer**: 개별 행성 렌더링\n- **HoverPreviewCard**: 호버 시 미리보기 카드\n- **PlanetDetailModal**: 상세 정보 모달\n- **NavigationControls**: 줌/패닝 컨트롤\n\n### 폼 컴포넌트\n- **AdoptionForm**: 행성 분양 신청 폼\n- **FileUploader**: 드래그 앤 드롭 업로드\n- **PlanetTypeSelector**: 행성 유형 선택 그리드\n- **FormField**: 재사용 가능한 입력 필드\n- **ValidationMessage**: 에러/성공 메시지\n\n### 관리자 컴포넌트\n- **AdminSidebar**: 관리자 사이드바 네비게이션\n- **PendingTable**: 승인 대기 목록 테이블\n- **ApprovalActions**: 승인/거절 버튼 그룹\n- **PlanetPreview**: 행성 미리보기 모달\n- **AnalyticsChart**: 기본 통계 차트\n\n### 카드 컴포넌트\n- **GamePreviewCard**: 게임 미리보기 카드\n- **PlanetInfoCard**: 행성 정보 카드\n- **StatCard**: 통계 정보 카드\n- **SuccessCard**: 성공 메시지 카드\n\n### UI 기본 컴포넌트\n- **Button**: Primary/Secondary/Ghost 버튼\n- **Input**: 텍스트 입력 필드\n- **Select**: 드롭다운 선택\n- **Modal**: 기본 모달 래퍼\n- **Badge**: 상태 표시 뱃지\n- **ProgressBar**: 진행률 표시바",
      "writedAt": "2025-08-29T14:05:03.108Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-08-29T14:05:03.108Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-08-29T14:05:03.108Z"
    }
  ]
}